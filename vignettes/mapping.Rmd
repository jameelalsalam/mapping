---
title: "mapping"
---

# Value Mapping

Various parts of base R and the tidyverse use different ways to map values to other values.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mappers)
```

The package {plyr} uses different approaches in the `revalue` and `mapvalues` functions. The `revalue` function can revalue character vectors and factors only because it uses a named vector for its map, and the keys of a named vector are character values.

```{r plyr_revalue}
chr_x <- c("a", "b", "c")
dbl_x <- c(0, 1, 2)

map_nmd_vec_chr <- c("a" = "A", "c" = "C")
plyr::revalue(chr_x, map_nmd_vec_chr)

map_nmd_vec_dbl <- c("1" = 42)
# plyr::revalue(dbl_x, map_nmd_vec_dbl) #errors
```

The mapvalues function uses parallel `from` and `to` vectors, so it can map arbitray keys and values.

```{r plyr_mapvalues}

from_vec <- c("a", "c")
to_vec <- c("A", "C")

plyr::mapvalues(chr_x, from_vec, to_vec)

from_dbl <- c(1, 2)
to_dbl <- c(42, 1111)

plyr::mapvalues(dbl_x, from_dbl, to_dbl)
```

The `dplyr` replacement for these `plyr` functions is `recode`. This function takes the `relevel` approach from `plyr`, but as dots, so the named vector (or named list) must be splatted with !!! from rlang.

```{r dplyr recode}
dplyr::recode(chr_x, !!!map_nmd_vec_chr)

map_nmd_list <- list("a" = "A", "c" = "C")

dplyr::recode(chr_x, !!!map_nmd_list)
```

The Advanced R book highlights character subsetting with a named vector as a powerful way to construct lookup tables, which is the same concept.

```{r adv-r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)
lookup[x]
```

It notes that in order to end up with an unnamed vector, you need to unname the result. This approach replaces all values, as opposed the patching approach in plyr and dplyr functions, so the lookup table must be complete. Again, this approach only can use character keys.

The patching behavior can be recovered with `dplyr::coalesce`.

```{r}
unname(lookup[x])

dplyr::coalesce(lookup[x], x)
```

`dplyr` joins present a different approach for mapping values, but focused on data frames. For the prototypical single-valued (function) map, you need to make sure the lookup table is unique.

```{r dplyr_joins}
library(magrittr)

map_df <- tibble(from = c("a", "c"), to = c("A", "C"))

tibble::tibble(x = chr_x) %>% dplyr::left_join(map_df, by = c("x" = "from")) %>% dplyr::pull(to)
```

Seems like a lot to map a vector, but in many cases, I believe this is actually faster. In addition, like plyr::mapvalues, it can handle arbitrary types. And soon, with dplyr 1.0.0, it will handle even more.

## ggplot2

The grammar of grammar of graphics, and ggplot2, does a lot of mapping values.

The core feature of ggplot2, the aesthetic mapping, constructs a map from data values to aesthetic values.
In addition, various features such as `scale_color_manual` and statistical transforms need to map values to other values.


```{r ggplot}

```

The scales labelling functions take values and map them to character vectors, using a 'labelling function' (generated by the `scales::label_` functions) as the map. These labeller functions are designed to work with the 'labels' parameter of ggplot2 scales.

```{r scales}
tibble(
  from = dbl_x,
  to = scales::label_dollar()(dbl_x)
)

```



